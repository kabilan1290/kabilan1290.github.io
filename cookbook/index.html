<!DOCTYPE html>
<html>
<head>
	<title>HTML Parser & Quirks - A Cookbook</title>
</head>
<style>
	html{
  --color-secondary: #30302f;
}
body {
    margin: 0;
    padding: 0;
    font-weight: bold;
    font-family: 'Space Mono', monospace;
    background-color: #2c2c2c;
    color: #fff;

    display: grid;
    background-color: black;
    margin: 0rem;

}
h1{
	color: #0ABABA;
}

h2{
	color: black;
}
.faq {
  padding: 40px;
  text-align: center;
  border-radius: 10px;
  box-shadow: 0 0 12px rgba(0, 0, 0, 0.25);
  color: black;
}



details {
  background-color: white;
  border-radius: 10px;
  cursor: pointer;
  padding: 20px 30px;
  margin-block: 30px;
}

summary,
p {
  text-align: left;
}

summary {
  margin-inline-start: 1rem;
  list-style-position: outside;
}

summary::marker {
  color: #8b7197;
  font-size: 18px;
}
.code-block {
  background-color: #1e1e1e;
  color: #d4d4d4;
  font-family: 'JetBrains Mono', 'IBM Plex Mono', 'Fira Code', 'Courier New', Courier, monospace;
  font-weight: 300;
  font-size: 16px;
  padding: 16px;
  overflow-x: auto;
  line-height: 1.5;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  border: 1px solid #3c3c3c;
  text-align: left; /* Ensures text is left-aligned */
}

.code-block code {
  display: block;
  white-space: pre-wrap;
  text-align: left; /* Left-aligns code inside */
}


.code-block::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.code-block::-webkit-scrollbar-thumb {
  background: #555;
  border-radius: 4px;
}

.code-block::-webkit-scrollbar-track {
  background: #2a2a2a;
}

</style>
<body>
<center><h1>HTML Parser & Quirks - A Cookbook</h1></center>
<p><b style="color:#0ABABA;">HTML Parser & Quirks</b> - A Cookbook: A collection of recipes exploring HTML parsing behaviors, treating parsing techniques as ingredients to craft structured data from raw markup. üçΩÔ∏èüìú</p>

<div class="faq">
	 <details>
    <summary><b style="color:#0ABABA;">Parsing,Styling,Layout,Painting</b></summary>
    <p>When you visit a webpage, you see the final polished visual content displayed on your screen, but have you ever wondered about the fascinating journey that transforms raw code into the interactive, dynamic page you're experiencing? Behind the scenes, your browser orchestrates a sophisticated multi-stage process that converts simple text-based markup into a fully functional web application. This transformation involves several critical steps that work together like a well-oiled machine - from parsing the initial HTML structure to applying visual styles, calculating precise layouts, and finally painting every pixel onto your display. Let's break down these fundamental steps in simple, digestible terms to understand the magic that happens every time you load a webpage.
<br><br>

    	<p><b style="color:#0ABABA;">1. Parsing [Building the DOM]</b> ‚Äì The very first thing the browser does is read the raw HTML code of the webpage. It then transforms this code into a structured format known as the DOM, or Document Object Model. Think of the DOM as a family tree for your webpage, where each HTML tag (like &lt;div&gt;, &lt;p&gt;, or &lt;img&gt;) becomes a "node" or branch in this tree. This structure allows the browser to understand the relationships between different parts of the page‚Äîsuch as which elements are inside others‚Äîand sets the foundation for everything else that happens next. By building the DOM, the browser creates a map it can use to display, style, and interact with the content you see.</p><br>
    	<img src="parsing.jpg" height=400px width=600px>	<img src="dom.jpg" height=400px width=600px>

    	<p><b style="color:#0ABABA;">2. Styling [Applying CSS]</b> ‚Äì After building the structure of the page, the browser needs to decide how everything should look. This is where CSS (Cascading Style Sheets) comes in. The browser reads all the CSS rules and determines the visual appearance of each element‚Äîsuch as its colors, fonts, sizes, spacing, and more. It matches these style rules to the right elements in the DOM, making sure that headings stand out, links are colored, and buttons look clickable. This step transforms the plain structure into a visually appealing and organized page, giving each part its unique style and personality so that the website looks attractive and is easy to use.</p><br>
    	    	<img src="style2.jpg" height=400px width=600px>	<img src="style1.jpg" height=400px width=600px>


    	<p><b style="color:#0ABABA;">3. Layout [Positioning Elements]</b> ‚Äì Once the browser knows what each element is and how it should look, it needs to figure out exactly where everything should go on the page. This process is called ‚Äúlayout.‚Äù The browser carefully calculates the size and position of every element‚Äîlike headings, paragraphs, images, and buttons‚Äîby following the rules set by CSS and the structure of the HTML. It makes sure that nothing overlaps in a way it shouldn‚Äôt, and that all the pieces fit together neatly, no matter the size of your screen or window. This step is like arranging the pieces of a puzzle so that the final picture looks just right for you.</p><br>
    	<img src="layout.jpg" height=400px width=600px>

    	<p><b style="color:#0ABABA;">4. Painting [Rendering Pixels]</b> ‚Äì In this final stage, the browser gathers everything it has learned from parsing the HTML, applying CSS styles, and calculating the layout. It then translates all this information into actual pixels‚Äîthe tiny dots that make up the images and text you see on your screen. This process is called ‚Äúpainting.‚Äù The browser carefully draws each element, layer by layer, so that the web page appears exactly as intended. Only after this step does the content become visible and interactive for you, the user. In other words, painting is the moment when all the behind-the-scenes work comes together and the web page finally appears before your eyes.</p><br>
    	    	<img src="paint.png" height=400px width=600px><br>
    	ref: <a href="https://www.chromium.org/developers/the-rendering-critical-path/">The rendering critical path</a><br>
    	ref:<a href="https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_188">The life of a pixel</a>- The images used were from the slides.<br>
                  <a href="https://www.youtube.com/watch?v=a2_6bGNZ7bA">Faster HTML and CSS: Layout Engine Internals for Web Developers</a>- Interesting video from the past !<br>



</p>
  </details>
  <details>
    <summary><b style="color:#0ABABA;">HTML Parsing: Understanding the Backbone of Web Rendering</b></summary>
    <p>HTML parsing is the process of reading an HTML document and converting it into a structured format that can be processed by a browser,Parsing a HTML document goes through the below stages !</p>
    <p><img src="stages.png" height=250px width=250px><br></p>
    <p><b style="color:#0ABABA;">Example:</b>&lt;!doctype html&gt;&lt;p&gt;helloworld
    <p>Let's take this simple example and walk through how the parser processes it step by step, showing you exactly what happens behind the scenes when the browser encounters even the most basic HTML content.<br><br>
    <p><b style="color:#0ABABA;">Step 1:</b> Bytes travel over the network and a decoder converts them into a stream of code points (the individual characters that make up the text). This is like translating a foreign language into something the browser can understand.</p>
    <p><b style="color:#0ABABA;">Step 2:</b> The tokenizer carefully walks through this stream of code points, character by character, and identifies meaningful pieces called "tokens." It's like breaking down a sentence into individual words and punctuation marks.</p>
    <p><b style="color:#0ABABA;">Step 3:</b> From our example, the tokenizer generates specific tokens: a doctype token (indicating this is HTML5), a start tag token for the &lt;p&gt; element, and a series of character tokens for "helloworld".</p>
    <p><b style="color:#0ABABA;">Step 4:</b> The tree builder takes these tokens and constructs the final DOM structure. It's like building a family tree where each element has its proper place and relationships.</p>
    <pre style="text-align: left;">
Document 
	‚îî‚îÄ‚îÄ html 
    		‚îî‚îÄ‚îÄ body 
        		‚îî‚îÄ‚îÄ p 
            		    ‚îî‚îÄ‚îÄ #text: helloworld
    </pre>
    <img src="helloworld.png">
    <p>Even this simple "helloworld" text that you see on screen has to go through all these complex parsing stages before it can be displayed! This shows just how much work the browser does behind the scenes to make web pages work smoothly.<br>
    	<center>ref: <a href="https://htmlparser.info/">Idiosyncrasies of the HTML parser</a>
  </details>
  <details>
    <summary><b style="color:#0ABABA;">Content Type:</b></summary>
    <p>The HTTP Content-Type header is like a label that tells the browser exactly what type of content it's about to receive‚Äîwhether it's HTML, an image, a PDF, or any other file format. This header acts as a crucial communication tool between the web server and your browser, ensuring that the content is interpreted and displayed correctly. But what happens when this important label is missing? How does the browser figure out what to do with the content it receives?</p>
    <p>This is where <b style="color:#0ABABA;">content sniffing</b> comes into play‚Äîa fascinating process where the browser becomes a detective, examining the actual content to determine its type. Let's explore this through some practical examples that will show you exactly how this works in real-world scenarios.</p>
    <p><b style="color:#0ABABA;">Example 1:</b> Let's start by testing what happens when we try to render a simple &lt;h1&gt; heading tag without a content-type header:</p>
    <img src='renderh1.png' height=300px width=600px><p>As expected, the &lt;h1&gt; tag renders perfectly as HTML! This makes sense because &lt;h1&gt; is a common HTML element that browsers recognize immediately.</p>
    <p><b style="color:#0ABABA;">Example 2:</b> Now let's try something more interesting‚Äîwhat happens when we test a &lt;h2&gt; tag?</p>
    <center><img src='renderh2.png' height=300px width=600px><p>Surprisingly, the &lt;h2&gt; tag is rendered as plain text instead of HTML! This unexpected behavior reveals something important about how browsers work.</p>
    <p>This difference in behavior occurs because browsers use a sophisticated set of rules and algorithms to "sniff" or detect content types when the Content-Type header is missing. These rules are implemented in code that acts like a security guard, checking for specific patterns and tags that indicate HTML content.</p>
    <p>Below is the actual code from a browser's HTML sniffer. This code tells the browser which specific tags should trigger HTML rendering when no content-type is specified:</p>
<pre class="code-block">
// Our HTML sniffer differs slightly from Mozilla.  For example, Mozilla will
// decide that a document that begins &#x22;&#x3C;!DOCTYPE SOAP-ENV:Envelope PUBLIC/&#x22; is
// HTML, but we will not.

#define MAGIC_HTML_TAG(tag) \
  MAGIC_STRING(&#x22;text/html&#x22;, &#x22;&#x3C;&#x22; tag)

static const MagicNumber kSniffableTags[] = {
  // XML processing directive.  Although this is not an HTML mime type, we sniff
  // for this in the HTML phase because text/xml is just as powerful as HTML and
  // we want to leverage our white space skipping technology.
  MAGIC_NUMBER(&#x22;text/xml&#x22;, &#x22;&#x3C;?xml&#x22;),  // Mozilla
  // DOCTYPEs
  MAGIC_HTML_TAG(&#x22;!DOCTYPE html&#x22;),  // HTML5 spec
  // Sniffable tags, ordered by how often they occur in sniffable documents.
  MAGIC_HTML_TAG(&#x22;script&#x22;),  // HTML5 spec, Mozilla
  MAGIC_HTML_TAG(&#x22;html&#x22;),  // HTML5 spec, Mozilla
  MAGIC_HTML_TAG(&#x22;!--&#x22;),
  MAGIC_HTML_TAG(&#x22;head&#x22;),  // HTML5 spec, Mozilla
  MAGIC_HTML_TAG(&#x22;iframe&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;h1&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;div&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;font&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;table&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;a&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;style&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;title&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;b&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;body&#x22;),  // Mozilla
  MAGIC_HTML_TAG(&#x22;br&#x22;),
  MAGIC_HTML_TAG(&#x22;p&#x22;),  // Mozilla
};

// ...

// Returns true and sets result if the content appears to be HTML.
// Clears have_enough_content if more data could possibly change the result.
static bool SniffForHTML(base::StringPiece content,
                         bool* have_enough_content,
                         std::string* result) {
  // For HTML, we are willing to consider up to 512 bytes. This may be overly
  // conservative as IE only considers 256.
  *have_enough_content &#x26;= TruncateStringPiece(512, &#x26;content);

  // We adopt a strategy similar to that used by Mozilla to sniff HTML tags,
  // but with some modifications to better match the HTML5 spec.
  base::StringPiece trimmed =
      base::TrimWhitespaceASCII(content, base::TRIM_LEADING);

  // |trimmed| now starts at first non-whitespace character (or is empty).
  return CheckForMagicNumbers(trimmed, kSniffableTags, result);
}
</pre>
  <h1><p> Quick Question : </h1>
    <p>Based on the code above, if no content type is defined, are only the HTML elements/tags listed below responsible for rendering HTML, or can rendering be forced using other methods or elements?</p>
      <pre class="code-block">
        &lt;!DOCTYPE html&gt;,&lt;script&gt;,&lt;html,&lt;!--&gt;,&lt;head&gt;,&lt;iframe&gt;,&lt;h1&gt;,&lt;div&gt;,&lt;font&gt;,&lt;table&gt;,&lt;a&gt;,&lt;style&gt;,&lt;title&gt;,&lt;body&gt;,&lt;br&gt;,&lt;p&gt;
      </pre>
      <img src='picture.jpg' height=300px width=600px>
<p><b style="color:#0ABABA;">Interesting Discovery:</b> The picture element works perfectly! But wait‚Äîit's not explicitly defined in the sniffer code above. So how does it work?</p>
<p>The answer lies in how the sniffer algorithm operates. Since the &lt;picture&gt; tag starts with the letter 'p' and the code includes <code>MAGIC_HTML_TAG(&#x22;p&#x22;)</code>, any tag that begins with 'p' (like 'picture', 'progress', 'param', etc.) will trigger HTML rendering. This is a clever but potentially exploitable feature of the content sniffing mechanism.</p>
  <p>I discovered this fascinating behavior while working on a challenge from the Dreamhack wargame <a href="https://dreamhack.io/wargame/challenges/1787">Small File Storage</a>! Special thanks to my friends <b style="color:#0ABABA;">0xAlessandro</b> and <b style="color:#0ABABA;">Yuu</b> for the insights.</p>
<p>To dive deeper into this topic, visit <a href="https://aszx87410.github.io/beyond-xss/en/ch5/mime-sniffing/">Mime Sniffing</a> for a comprehensive exploration of content type detection mechanisms.

  </details>
  <details>
    <summary><b style="color:#0ABABA;">Character encoding:</b></summary>
    <p>HTML parser need to know the definite encoding to operate on an input byte stream of the document.
    <p>The character encoding can be defined using meta tag &lt;meta charset="utf-8"&gt; or it can be specified at the transport layer, HTTP Content-Type with charset parameter which gives the encoding of the document.</p>
    <p>The document can also start with Byte Order Mark (BOM),If the document starts with the bytes given in the below column,then return the encoding correspondingly.</p>
      <img src='bom.png'>
      <p>The precedence order for character encoding is Byte Order Mark (BOM) > HTTP Content-Type Header > Meta Tag in HTML rendering.</p>
      <p>Before the HTML parser starts,a prescan of the byte stream can take place in an attempt to find the character encoding declaration.The prescan is usually done on the first 1024 bytes and there's a requirement for documents to include encoding declaration within 1024 bytes.
          <h1><p> Quick Question : </h1>
            <p>What if no charset is defined ?
              <p>If no encoding declaration is found,then the default will usually depend on the user's locale and the most common default is windows-1252.
                      <center><img src='nochar.png' height=300px width=600px>
              <p> We can also abuse Encoding Differentials in absence of charsets, you can read more about it here <a href="https://www.sonarsource.com/blog/encoding-differentials-why-charset-matters/"> Encoding Differentials: Why Charset Matters </a>

        </details>

    <details>
    <summary><b style="color:#0ABABA;">Error Handling:</b></summary>
    <p>HTML parsing is remarkably forgiving,unlike many programming languages that crash when they encounter errors, HTML parsers are designed to be resilient and user-friendly. The HTML specification provides detailed instructions on how browsers should handle various types of errors that might occur while reading an HTML document. This approach ensures that web pages can still be displayed and function properly, even when the underlying HTML code isn't perfect.</p>
    
    <p>When a browser encounters HTML errors, it doesn't simply stop processing or display an error message to users. Instead, it follows a sophisticated set of recovery rules defined in the HTML specification. These rules act like a safety net, allowing the browser to intelligently fix common mistakes and continue rendering the page. This error-handling mechanism is crucial because real-world HTML is often generated by various tools, content management systems, or even written by humans who might make mistakes.</p>
    
    <p>The HTML parser is particularly good at handling three common types of errors: <b style="color:#0ABABA;">unclosed tags</b>, <b style="color:#0ABABA;">missing quotes</b>, and <b style="color:#0ABABA;">incorrect tag nesting</b>. When it encounters these issues, the parser doesn't crash or give up. Instead, it applies fixes to ensure the page can still be displayed as correctly as possible, maintaining both functionality and visual appearance.</p>
    
    <h3><p><b style="color:#0ABABA;">Real-World Examples:</b></p></h3>
    
    <p><b style="color:#0ABABA;">Example 1: Unclosed Tags</b></p>
    <center><img src='close.png' height=300px width=800px></center><br>
    <p><b style="color:#0ABABA;">What happened:</b> The parser encountered an opening &lt;p&gt; tag without a corresponding closing tag. Instead of breaking, it automatically closed the paragraph when it encountered the next element. This ensures that the content flows properly and maintains the intended structure.</p><br>
    
    <p><b style="color:#0ABABA;">Example 2: Missing Quotes</b></p>
    <center><img src='attriclose.png' height=300px width=800px></center><br>
    <p><b style="color:#0ABABA;">What happened:</b> The image tag was missing quotes around its attribute values. The parser intelligently added the missing quotes, ensuring that the image element is properly formed and can be rendered correctly.</p><br>
    
    <p><b style="color:#0ABABA;">Example 3: Incorrect Nesting</b></p>
    <center><img src='nestclose.png' height=300px width=800px></center><br>
    <p><b style="color:#0ABABA;">What happened:</b> The HTML had semantically incorrect nesting‚Äîa heading tag was placed inside another heading tag, which doesn't make logical sense. The parser automatically adjusted the structure to create a meaningful hierarchy, ensuring that the content is displayed in a sensible and accessible way.</p><br>

    <p>This error-handling approach makes the web more robust and user-friendly. It means that even if a web developer makes a small mistake in their HTML code, users can still access and use the website without encountering frustrating error messages or broken pages. This is one of the reasons why the web has been so successful‚Äîit prioritizes user experience over strict technical perfection.</p>

  </details>

  <details>
    <summary><b style="color:#0ABABA;">Adoption Agency Algorithm :</b></summary>
    <p>The Adoption Agency Algorithm is a process used in HTML to fix incorrect nesting of elements.
      <pre class="code-block">
        &lt;p>1&lt;b>2&lt;i>3&lt;/b>4&lt;/i>5&lt;/p>
      </pre>
            <center><img src='bi1.png' height=200px width=400px></center><br>

  </details>

</div>
</body>